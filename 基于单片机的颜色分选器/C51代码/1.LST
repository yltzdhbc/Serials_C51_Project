C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE 1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*实现功能:对颜色传感器输出RGB
   2          得出数据后可到http://www.59178.com/tools/sejie.asp查询数据是否正确
   3          使用芯片：AT89S52 或者 STC89C52 或AT89S51 STC89C51
   4          晶振：12MHZ
   5          编译环境：Keil
   6          作者：zhengzhongxign39*/
   7          #include <reg52.h>
   8          #define uchar unsigned char
   9          #define uint unsigned int
  10          //==============LCD1602接口连接方法=====================
  11          /*-----------------------------------------------------
  12                 |DB0-----P2.0 | DB4-----P2.4 | RW-------P0.6    |
  13                 |DB1-----P2.1 | DB5-----P2.5 | RS-------P0.7    |
  14                 |DB2-----P2.2 | DB6-----P2.6 | E--------P0.5    |
  15                 |DB3-----P2.3 | DB7-----P2.7 | 
  16              ---------------------------------------------------*/
  17          //================================================*/
  18          #define LCM_Data P0   //LCD1602数据接口
  19          #define Busy 0x80     //用于检测LCM状态字中的Busy标识
  20          sbit LCM_RW = P2 ^ 1; //读写控制输入端，LCD1602的第五脚
  21          sbit LCM_RS = P2 ^ 0; //寄存器选择输入端，LCD1602的第四脚
  22          sbit LCM_E = P2 ^ 2;  //使能信号输入端,LCD1602的第6脚
  23          
  24          //=================颜色传感模块连接=====================
  25          /*-----------------------------------------------------
  26                 |EO-----GND
  27                 |S0-----VCC | S2-----P1.0 | OUT-------P3.5 
  28                 |S1-----VCC | S3-----P1.1 | 
  29            ---------------------------------------------------*/
  30          sbit tcs230_s2 = P1 ^ 0; //TCS230 S2接单片机P1.0
  31          sbit tcs230_s3 = P1 ^ 1; //TCS230 S3接单片机P1.1
  32          sbit tcs230_en = P1 ^ 2; //TCS230 EN(E0)接GND
  33          //**************函数声明***************************************
  34          void WriteDataLCM(uchar WDLCM);                     //LCD模块写数据
  35          void WriteCommandLCM(uchar WCLCM, BuysC);           //LCD模块写指令
  36          uchar ReadStatusLCM(void);                          //读LCD模块的忙标
  37          void DisplayOneChar(uchar X, uchar Y, uchar ASCII); //在第X+1行的第Y+1位置显示一个字符
  38          void LCMInit(void);                                 //LCD初始
  39          void DelayMs(uint Ms);                              //1MS基准延时程序
  40          void baipingheng();                                 //白平衡子程序
  41          void celiang();                                     //实际颜色程序
  42          uint ryz, gyz, byz;                                 //分别定义红色因子 绿色因子 蓝色因子
  43          uint rb, gb, bb;                                    //RGB值
  44          uchar tab1[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
  45          
  46          sbit PIN_RELAY1 = P1 ^ 7 ;//继电器端口
  47          sbit PIN_RELAY2 = P1 ^ 6 ;//继电器端口
  48          sbit PIN_RELAY3 = P1 ^ 5 ;//继电器端口
  49          
  50          
  51          //*********分选装置子函数***********
  52          void classify()
  53          {
  54   1        
  55   1        if((rb>bb)&&(rb>gb))//max=redValue;
C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 2   

  56   1        {
  57   2          PIN_RELAY2 = 1;//复位
  58   2          PIN_RELAY3 = 1;//复位
  59   2          PIN_RELAY1 = 0;//低电平触发
  60   2        }
  61   1        else if((gb>rb)&&(gb>bb))//max=greenValue;
  62   1        {
  63   2          PIN_RELAY1 = 1;//复位
  64   2          PIN_RELAY3 = 1;//复位
  65   2          PIN_RELAY2 = 0;//低电平触发
  66   2        }
  67   1        else if((bb>rb)&&(bb>gb))//max=blueValue;
  68   1        {
  69   2          PIN_RELAY1 = 1;//复位
  70   2          PIN_RELAY2 = 1;//复位
  71   2          PIN_RELAY3 = 0;//低电平触发
  72   2        }
  73   1      }
  74          
  75          //***********************主程序******************************
  76          main()
  77          {
  78   1        TMOD = 0x51;   //设定T0以工作方式1定时10毫秒
  79   1        LCMInit();     //LCD初始
  80   1        baipingheng(); //上电时先白平衡一次
  81   1        while (1)
  82   1        {
  83   2          classify();
  84   2          celiang();                                 //颜色测试
  85   2          DisplayOneChar(0, 0, 'R');                 //以十进制显示RGB中红色的分值
  86   2          DisplayOneChar(0, 1, rb / 100 + 0x30);     //显示百位数据
  87   2          DisplayOneChar(0, 2, rb / 10 % 10 + 0x30); //显示十位数据
  88   2          DisplayOneChar(0, 3, rb % 10 + 0x30);      //显示个位数据
  89   2          DisplayOneChar(0, 5, 'G');                 //以十进制显示RGB中绿色的分值
  90   2          DisplayOneChar(0, 6, gb / 100 + 0x30);     //显示百位数据
  91   2          DisplayOneChar(0, 7, gb / 10 % 10 + 0x30);
  92   2          DisplayOneChar(0, 8, gb % 10 + 0x30);
  93   2          DisplayOneChar(0, 10, 'B'); //以十进制显示RGB中蓝色的分值
  94   2          DisplayOneChar(0, 11, bb / 100 + 0x30);
  95   2          DisplayOneChar(0, 12, bb / 10 % 10 + 0x30);
  96   2          DisplayOneChar(0, 13, bb % 10 + 0x30);
  97   2          //*****在LCD1602的第二行以16进制显示RGB*******************
  98   2          DisplayOneChar(1, 1, tab1[rb / 16]);
  99   2          DisplayOneChar(1, 2, tab1[rb % 16]);
 100   2          DisplayOneChar(1, 3, 'H');
 101   2          DisplayOneChar(1, 6, tab1[gb / 16]);
 102   2          DisplayOneChar(1, 7, tab1[rb % 16]);
 103   2          DisplayOneChar(1, 8, 'H');
 104   2          DisplayOneChar(1, 11, tab1[bb / 16]);
 105   2          DisplayOneChar(1, 12, tab1[bb % 16]);
 106   2          DisplayOneChar(1, 13, 'H');
 107   2          DelayMs(50); //每隔0.25秒测试一次颜色
 108   2        }
 109   1      }
 110          //******************************************************
 111          //白平衡子程序
 112          void celiang()
 113          {
 114   1        //*********求R值************************************
 115   1        TH0 = (65536 - 10000) / 256;
 116   1        TL0 = (65536 - 10000) % 256;
 117   1        TH1 = 0;
C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 3   

 118   1        TL1 = 0;
 119   1        tcs230_s2 = 0;
 120   1        tcs230_s3 = 0; //选择红色滤光器
 121   1        tcs230_en = 0;
 122   1        TR0 = 1; //10毫秒开始计时
 123   1        TR1 = 1; //开始计数
 124   1        while (TF0 == 0)
 125   1          ;      //等待定时器溢出
 126   1        TF0 = 0; //清楚定时器0溢出标志
 127   1        TR0 = 0; //关闭定时0
 128   1        TR1 = 0;
 129   1        rb = (unsigned long)(TH1 * 256 + TL1) * 255 / ryz;
 130   1        if (rb > 255)
 131   1          rb = 255; //判断RGB值是否合法
 132   1        //***********求B值**************************************
 133   1        TH0 = (65536 - 10000) / 256;
 134   1        TL0 = (65536 - 10000) % 256;
 135   1        TH1 = 0;
 136   1        TL1 = 0;
 137   1        tcs230_s2 = 0;
 138   1        tcs230_s3 = 1; //选择蓝色滤光器
 139   1        TR0 = 1;       //10毫秒开始计时
 140   1        TR1 = 1;       //开始计数
 141   1        while (TF0 == 0)
 142   1          ;      //等待定时器溢出
 143   1        TF0 = 0; //清楚定时器0溢出标志
 144   1        TR0 = 0; //关闭定时0
 145   1        TR1 = 0;
 146   1        bb = (unsigned long)(TH1 * 256 + TL1) * 255 / byz;
 147   1        if (bb > 255)
 148   1          bb = 255; //判断RGB值是否合法
 149   1        //***********求G值**************************************
 150   1        TH0 = (65536 - 10000) / 256;
 151   1        TL0 = (65536 - 10000) % 256;
 152   1        TH1 = 0;
 153   1        TL1 = 0;
 154   1        tcs230_s2 = 1;
 155   1        tcs230_s3 = 1; //选择绿色滤光器
 156   1        TR0 = 1;       //10毫秒开始计时
 157   1        TR1 = 1;       //开始计数
 158   1        while (TF0 == 0)
 159   1          ;      //等待定时器溢出
 160   1        TF0 = 0; //清楚定时器0溢出标志
 161   1        TR0 = 0; //关闭定时0
 162   1        TR1 = 0;
 163   1        tcs230_en = 1;
 164   1        gb = (unsigned long)(TH1 * 256 + TL1) * 255 / gyz;
 165   1        if (gb > 255)
 166   1          gb = 255; //判断RGB值是否合法
 167   1      }
 168          //******************************************************
 169          //白平衡子程序
 170          void baipingheng()
 171          {
 172   1        //**************求取红色因子***********************
 173   1        TH0 = (65536 - 10000) / 256;
 174   1        TL0 = (65536 - 10000) % 256;
 175   1        TH1 = 0;
 176   1        TL1 = 0;
 177   1        tcs230_s2 = 0;
 178   1        tcs230_s3 = 0; //选择红色滤光器
 179   1        tcs230_en = 0;
C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 4   

 180   1        TR0 = 1; //10毫秒开始计时
 181   1        TR1 = 1; //开始计数
 182   1        while (TF0 == 0)
 183   1          ;      //等待定时器溢出
 184   1        TF0 = 0; //清楚定时器0溢出标志
 185   1        TR0 = 0; //关闭定时0
 186   1        TR1 = 0;
 187   1        ryz = TH1 * 256 + TL1; //其实这里的比例因子应该为255/(TH1*256+TL1)
 188   1        //**************求取蓝色因子***********************
 189   1        TH0 = (65536 - 10000) / 256;
 190   1        TL0 = (65536 - 10000) % 256;
 191   1        TH1 = 0;
 192   1        TL1 = 0;
 193   1        tcs230_s2 = 0;
 194   1        tcs230_s3 = 1; //选择蓝色滤光器
 195   1        TR0 = 1;       //10毫秒开始计时
 196   1        TR1 = 1;       //开始计数
 197   1        while (TF0 == 0)
 198   1          ;      //等待定时器溢出
 199   1        TF0 = 0; //清楚定时器0溢出标志
 200   1        TR0 = 0; //关闭定时0
 201   1        TR1 = 0;
 202   1        byz = TH1 * 256 + TL1; //其实这里的比例因子应该为255/(TH1*256+TL1)
 203   1        //**************求绿红色因子***********************
 204   1        TH0 = (65536 - 10000) / 256;
 205   1        TL0 = (65536 - 10000) % 256;
 206   1        TH1 = 0;
 207   1        TL1 = 0;
 208   1        tcs230_s2 = 1;
 209   1        tcs230_s3 = 1; //选择绿色滤光器
 210   1        TR0 = 1;       //10毫秒开始计时
 211   1        TR1 = 1;       //开始计数
 212   1        while (TF0 == 0)
 213   1          ;      //等待定时器溢出
 214   1        TF0 = 0; //清楚定时器0溢出标志
 215   1        TR0 = 0; //关闭定时0
 216   1        TR1 = 0;
 217   1        tcs230_en = 1;
 218   1        gyz = TH1 * 256 + TL1; //其实这里的比例因子应该为255/(TH1*256+TL1)
 219   1      }
 220          /*======================================================================
 221           LCM初始化
 222          ======================================================================*/
 223          void LCMInit(void)
 224          {
 225   1        LCM_Data = 0;
 226   1        WriteCommandLCM(0x38, 0); //三次显示模式设置，不检测忙信号
 227   1        DelayMs(5);
 228   1        WriteCommandLCM(0x38, 0);
 229   1        DelayMs(5);
 230   1        WriteCommandLCM(0x38, 0);
 231   1        DelayMs(5);
 232   1        WriteCommandLCM(0x38, 1); //显示模式设置,开始要求每次检测忙信号
 233   1        WriteCommandLCM(0x08, 1); //关闭显示
 234   1        WriteCommandLCM(0x01, 1); //显示清屏
 235   1        WriteCommandLCM(0x06, 1); // 显示光标移动设置
 236   1        WriteCommandLCM(0x0C, 1); // 显示开及光标设置
 237   1        DelayMs(100);
 238   1      }
 239          //==============================LCD1602显示子程序================================================
 240          // 写数据函数: E =高脉冲 RS=1 RW=0
 241          //======================================================================*/
C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 5   

 242          void WriteDataLCM(uchar WDLCM)
 243          {
 244   1        ReadStatusLCM(); //检测忙
 245   1        LCM_Data = WDLCM;
 246   1        LCM_RS = 1;
 247   1        LCM_RW = 0;
 248   1        LCM_E = 0; //若晶振速度太高可以在这后加小的延时
 249   1        LCM_E = 0; //延时
 250   1        LCM_E = 1;
 251   1      }
 252          /*====================================================================
 253            写指令函数: E=高脉冲 RS=0 RW=0
 254          ======================================================================*/
 255          void WriteCommandLCM(uchar WCLCM, BuysC) //BuysC为0时忽略忙检测
 256          {
 257   1        if (BuysC)
 258   1          ReadStatusLCM(); //根据需要检测忙
 259   1        LCM_Data = WCLCM;
 260   1        LCM_RS = 0;
 261   1        LCM_RW = 0;
 262   1        LCM_E = 0;
 263   1        LCM_E = 0;
 264   1        LCM_E = 1;
 265   1      }
 266          /*====================================================================
 267            正常读写操作之前必须检测LCD控制器状态:E=1 RS=0 RW=1;
 268            DB7: 0 LCD控制器空闲，1 LCD控制器忙。
 269            读状态
 270          ======================================================================*/
 271          uchar ReadStatusLCM(void)
 272          {
 273   1        LCM_Data = 0xFF;
 274   1        LCM_RS = 0;
 275   1        LCM_RW = 1;
 276   1        LCM_E = 0;
 277   1        LCM_E = 0;
 278   1        LCM_E = 1;
 279   1        while (LCM_Data & Busy)
 280   1          ; //检测忙信号
 281   1        return (LCM_Data);
 282   1      }
 283          /*======================================================================
 284          功 能:     在1602 指定位置显示一个字符:第一行位置0~15,第二行16~31
 285          说 明:     第 X 行,第 y 列  注意:字符串不能长于16个字符
 286          ======================================================================*/
 287          void DisplayOneChar(uchar X, uchar Y, uchar ASCII)
 288          {
 289   1        X &= 0x1;
 290   1        Y &= 0xF; //限制Y不能大于15，X不能大于1
 291   1        if (X)
 292   1          Y |= 0x40;           //当要显示第二行时地址码+0x40;
 293   1        Y |= 0x80;             // 算出指令码
 294   1        WriteCommandLCM(Y, 0); //这里不检测忙信号，发送地址码
 295   1        WriteDataLCM(ASCII);
 296   1      }
 297          /*====================================================================
 298            设定延时时间:x*1ms
 299          ====================================================================*/
 300          void DelayMs(uint Ms)
 301          {
 302   1        uint i, TempCyc;
 303   1        for (i = 0; i < Ms; i++)
C51 COMPILER V9.60.0.0   1                                                                 03/28/2020 22:42:34 PAGE 6   

 304   1        {
 305   2          TempCyc = 250;
 306   2          while (TempCyc--)
 307   2            ;
 308   2        }
 309   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1123    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
